#!/usr/bin/bash

# led-disk mapping
mapping_method=hctl  # hctl, serial
led_map=(disk1 disk2 disk3 disk4 disk5 disk6 disk7 disk8)
# hctl, $> lsblk -S -o name,hctl
hctl_map=("0:0:0:0" "1:0:0:0" "2:0:0:0" "3:0:0:0" "4:0:0:0" "5:0:0:0" "6:0:0:0" "7:0:0:0")
# serial number, $> lsblk -S -o name,serial
serial_map=("placeholder0" "placeholder1" "placeholder2" "placeholder3" "placeholder4" "placeholder5" "placeholder6" "placeholder7")
declare -A devices

# monitor dist SMART information
CHECK_SMART=true
# polling rate for smartctl. roughly 360 seconds by default
smart_poll_interval=3600




{ lsmod | grep ledtrig_oneshot ; } || modprobe -v ledtrig_oneshot

sleep 2

echo Enumerating disks based on $mapping_method...
declare -A dev_map
while read line
do
    blk_line=($line)
    if [[ $mapping_method = hctl ]]; then
        key=${blk_line[1]}
        val=${blk_line[0]}
    elif [[ $mapping_method = serial ]]; then
        key=${blk_line[1]}
        val=${blk_line[0]}
    else
        echo Unsupported mapping method: ${mapping_method}
        exit 1
    fi
    dev_map[${key}]=${val}
    echo $mapping_method ${key} ">>" ${dev_map[${key}]}
done <<< "$(lsblk -S -o name,${mapping_method} | tail -n +2)"

for i in "${!led_map[@]}"; do
    led=${led_map[i]} 
    if [[ -d /sys/class/leds/$led ]]; then
        echo oneshot > /sys/class/leds/$led/trigger
        echo 1 > /sys/class/leds/$led/invert
        echo 100 > /sys/class/leds/$led/delay_on
        echo 100 > /sys/class/leds/$led/delay_off
        echo "255 255 255" > /sys/class/leds/$led/color

        # find corresponding device
        _tmp_str=${mapping_method}_map[@]
        _tmp_arr=(${!_tmp_str})
        dev=${dev_map[${_tmp_arr[i]}]}
        if [[ -f /sys/class/block/${dev}/stat ]]; then
            devices[$led]=${dev}
        else
            # turn off the led if no disk installed on this slot
            echo 0 > /sys/class/leds/$led/brightness
            echo none > /sys/class/leds/$led/trigger
        fi
    fi
done

declare -A diskio_data_r
declare -A diskio_data_w
let loop_cnt=0
while true; do
    for led in "${!devices[@]}"; do
        dev=${devices[$led]}
        diskio_old_r=${diskio_data_r[$led]}
        diskio_old_w=${diskio_data_w[$led]}

        if [[ "$(cat /sys/class/leds/$led/color)" = "255 0 0" ]]; then
            continue;
        fi

        if [[ ! -f /sys/class/block/${dev}/stat ]]; then
            if [[ -f /sys/class/leds/$led/color ]]; then 
                echo "255 0 0" > /sys/class/leds/$led/color
                echo Disk /dev/$dev went offline at $(date +%Y-%m-%d' '%H:%M:%S)
                continue
            fi
        fi

        # check disk health
        if [ "$CHECK_SMART" = true ] && [[ ${loop_cnt} -eq 0 ]]; then
            if [[ -z $(smartctl -H /dev/${dev} | grep PASSED) ]]; then
                echo "255 0 0" > /sys/class/leds/$led/color
                echo Disk failure detected on /dev/$dev at $(date +%Y-%m-%d' '%H:%M:%S)
                continue
            fi
        fi

        diskio_new_r=$(cat /sys/block/${dev}/stat | awk '{ print $1 }')
        diskio_new_w=$(cat /sys/block/${dev}/stat | awk '{ print $4 }')

        if [ "${diskio_old_r}" != "${diskio_new_r}" ] || [ "${diskio_old_w}" != "${diskio_new_w}" ]; then
            echo 1 > /sys/class/leds/$led/shot
        fi

        diskio_data_r[$led]=$diskio_new_r
        diskio_data_w[$led]=$diskio_new_w
    done

    if [ -f /usr/bin/zpool-leds.sh ]; then
        bash /usr/bin/zpool-leds.sh
    fi

    sleep 0.1
    loop_cnt=$(($loop_cnt+1))
    loop_cnt=$(($loop_cnt%${smart_poll_interval}))

done
