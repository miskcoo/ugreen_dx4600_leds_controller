#!/usr/bin/bash

# function for removing lockfile
exit-ugreen-diskiomon() {
  if [[ -f "/var/run/ugreen-diskiomon.lock" ]]; then
    rm "/var/run/ugreen-diskiomon.lock"
  fi
  kill $smart_check_pid 2>/dev/null
}

# trap exit and remove lockfile
trap 'exit-ugreen-diskiomon' EXIT

# check if script is already running
if [[ -f "/var/run/ugreen-diskiomon.lock" ]]; then
  echo "ugreen-diskiomon already running!"
  exit 1
fi
touch /var/run/ugreen-diskiomon.lock

# led-disk mapping (see https://github.com/miskcoo/ugreen_dx4600_leds_controller/pull/4)
mapping_method=${mapping_method:=hctl} # hctl, serial
led_map=(disk1 disk2 disk3 disk4 disk5 disk6 disk7 disk8)

# hctl, $> lsblk -S -x hctl -o hctl,serial,name 
# NOTE: It is reported that the order below should be adjusted for each model. 
#       Please check the disk mapping section in https://github.com/miskcoo/ugreen_dx4600_leds_controller/blob/master/README.md.
hctl_map=("0:0:0:0" "1:0:0:0" "2:0:0:0" "3:0:0:0" "4:0:0:0" "5:0:0:0" "6:0:0:0" "7:0:0:0")
if which dmidecode; then
    product_name=$(dmidecode --string system-product-name)
    case "${product_name}" in 
        "DXP6800 Pro")
          echo "Found UGREEN DXP6800 Pro" 
          hctl_map=("2:0:0:0" "3:0:0:0" "4:0:0:0" "5:0:0:0" "0:0:0:0" "1:0:0:0")
          ;;
        "DX4600 Pro")
          echo "Found UGREEN DX4600 Pro" 
          # using the default mapping
          ;;
        "DXP8800 Plus")
          echo "Found UGREEN DXP8800 Plus" 
          # using the default mapping
          ;;
        *)
          if [[ "${mapping_method}" = "hctl" ]]; then
              echo "Using the default HCTL order. Please check it maps to your disk slots correctly."
              echo "If you confirm that the HCTL order is correct, or find it is different, you can submit an issue to let us know, so we can update the script."
              echo "(Read the disk mapping section in https://github.com/miskcoo/ugreen_dx4600_leds_controller/blob/master/README.md for more details)"
          fi
          ;;
    esac
elif [[ "${mapping_method}" = "hctl" ]]; then
    echo "installing the tool `dmidecode` is suggested; otherwise the script cannot detect your device and adjust the hctl_map"
fi 
# serial number, $> lsblk -S -x hctl -o hctl,serial,name 
serial_map=("placeholder0" "placeholder1" "placeholder2" "placeholder3" "placeholder4" "placeholder5" "placeholder6" "placeholder7")
declare -A devices

# set monitor SMART information to true by default if not running unRAID
if [[ -f /etc/unraid-version ]]; then
    CHECK_SMART=false
else
    CHECK_SMART=${CHECK_SMART:=true}
fi
# polling rate for smartctl. 360 seconds by default
CHECK_SMART_INTERVAL=${CHECK_SMART_INTERVAL:=360}
# refresh interval from disk leds
LED_REFRESH_INTERVAL=${LED_REFRESH_INTERVAL:=0.1}



{ lsmod | grep ledtrig_oneshot ; } || modprobe -v ledtrig_oneshot

sleep 2

echo Enumerating disks based on $mapping_method...
declare -A dev_map
while read line
do
    blk_line=($line)
    if [[ $mapping_method = hctl ]]; then
        key=${blk_line[1]}
        val=${blk_line[0]}
    elif [[ $mapping_method = serial ]]; then
        key=${blk_line[1]}
        val=${blk_line[0]}
    else
        echo Unsupported mapping method: ${mapping_method}
        exit 1
    fi
    dev_map[${key}]=${val}
    echo $mapping_method ${key} ">>" ${dev_map[${key}]}
done <<< "$(lsblk -S -o name,${mapping_method} | tail -n +2)"

for i in "${!led_map[@]}"; do
    led=${led_map[i]} 
    if [[ -d /sys/class/leds/$led ]]; then
        echo oneshot > /sys/class/leds/$led/trigger
        echo 1 > /sys/class/leds/$led/invert
        echo 100 > /sys/class/leds/$led/delay_on
        echo 100 > /sys/class/leds/$led/delay_off
        echo "255 255 255" > /sys/class/leds/$led/color

        # find corresponding device
        _tmp_str=${mapping_method}_map[@]
        _tmp_arr=(${!_tmp_str})
        dev=${dev_map[${_tmp_arr[i]}]}
        if [[ -f /sys/class/block/${dev}/stat ]]; then
            devices[$led]=${dev}
        else
            # turn off the led if no disk installed on this slot
            echo 0 > /sys/class/leds/$led/brightness
            echo none > /sys/class/leds/$led/trigger
        fi
    fi
done

# check disk health if enabled
if [ "$CHECK_SMART" = true ]; then
(
    while true; do
        for led in "${!devices[@]}"; do
            if [[ "$(cat /sys/class/leds/$led/color)" = "255 0 0" ]]; then
                continue;
            fi

            if [[ -z $(smartctl -H /dev/${dev} | grep PASSED) ]]; then
                echo "255 0 0" > /sys/class/leds/$led/color
                echo Disk failure detected on /dev/$dev at $(date +%Y-%m-%d' '%H:%M:%S)
                continue
            fi
        sleep ${CHECK_SMART_INTERVAL}s
    done
) &
smart_check_pid=$!
fi

# check for zpool-leds.sh and set variable
if [[ -f /usr/bin/zpool-leds.sh ]]; then
    ZPOOL_LEDS="bash /usr/bin/zpool-leds.sh"
else
    ZPOOL_LEDS=""
fi

declare -A diskio_data_r
declare -A diskio_data_w
while true; do
    for led in "${!devices[@]}"; do
        dev=${devices[$led]}
        diskio_old_r=${diskio_data_r[$led]}
        diskio_old_w=${diskio_data_w[$led]}

        if [[ "$(cat /sys/class/leds/$led/color)" = "255 0 0" ]]; then
            continue;
        fi

        if [[ ! -f /sys/class/block/${dev}/stat ]]; then
            echo "255 0 0" > /sys/class/leds/$led/color 2>/dev/null
            echo Disk /dev/$dev went offline at $(date +%Y-%m-%d' '%H:%M:%S)
            continue
        fi

        diskio_new_r=$(cat /sys/block/${dev}/stat | awk '{ print $1 }')
        diskio_new_w=$(cat /sys/block/${dev}/stat | awk '{ print $5 }')

        if [ "${diskio_old_r}" != "${diskio_new_r}" ] || [ "${diskio_old_w}" != "${diskio_new_w}" ]; then
            echo 1 > /sys/class/leds/$led/shot
        fi

        diskio_data_r[$led]=$diskio_new_r
        diskio_data_w[$led]=$diskio_new_w
    done

    ${ZPOOL_LEDS}

    sleep ${LED_REFRESH_INTERVAL}s

done
